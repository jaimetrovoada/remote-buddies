// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "User" ("name", "email", "image", "updated_at", "oauth_type", "oauth_provider", "oauth_providerAccountId", "oauth_refresh_token", "oauth_access_token", "oauth_token_type", "oauth_scope")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, name, email, "emailVerified", image, coords, interests, created_at, updated_at, oauth_type, oauth_provider, "oauth_providerAccountId", oauth_refresh_token, oauth_access_token, oauth_expires_at, oauth_token_type, oauth_scope, oauth_id_token, oauth_session_state, oauth_token_secret, oauth_token
`

type CreateUserParams struct {
	Name                   pgtype.Text        `json:"name"`
	Email                  pgtype.Text        `json:"email"`
	Image                  pgtype.Text        `json:"image"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	OauthType              pgtype.Text        `json:"oauth_type"`
	OauthProvider          pgtype.Text        `json:"oauth_provider"`
	OauthProviderAccountId string             `json:"oauth_providerAccountId"`
	OauthRefreshToken      pgtype.Text        `json:"oauth_refresh_token"`
	OauthAccessToken       pgtype.Text        `json:"oauth_access_token"`
	OauthTokenType         pgtype.Text        `json:"oauth_token_type"`
	OauthScope             pgtype.Text        `json:"oauth_scope"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Image,
		arg.UpdatedAt,
		arg.OauthType,
		arg.OauthProvider,
		arg.OauthProviderAccountId,
		arg.OauthRefreshToken,
		arg.OauthAccessToken,
		arg.OauthTokenType,
		arg.OauthScope,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.Coords,
		&i.Interests,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthType,
		&i.OauthProvider,
		&i.OauthProviderAccountId,
		&i.OauthRefreshToken,
		&i.OauthAccessToken,
		&i.OauthExpiresAt,
		&i.OauthTokenType,
		&i.OauthScope,
		&i.OauthIDToken,
		&i.OauthSessionState,
		&i.OauthTokenSecret,
		&i.OauthToken,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, name, email, "emailVerified", image, coords, interests, created_at, updated_at, oauth_type, oauth_provider, "oauth_providerAccountId", oauth_refresh_token, oauth_access_token, oauth_expires_at, oauth_token_type, oauth_scope, oauth_id_token, oauth_session_state, oauth_token_secret, oauth_token FROM "User" WHERE email = $1
`

// USER QUERIES
func (q *Queries) GetUser(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.Coords,
		&i.Interests,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OauthType,
		&i.OauthProvider,
		&i.OauthProviderAccountId,
		&i.OauthRefreshToken,
		&i.OauthAccessToken,
		&i.OauthExpiresAt,
		&i.OauthTokenType,
		&i.OauthScope,
		&i.OauthIDToken,
		&i.OauthSessionState,
		&i.OauthTokenSecret,
		&i.OauthToken,
	)
	return i, err
}

const listNearbyUsers = `-- name: ListNearbyUsers :many
SELECT name, st_astext(coords) as coords
FROM "User"
WHERE ST_DWithin(coords, ST_MakePoint($1, $2)::geography, $3)
`

type ListNearbyUsersParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
}

type ListNearbyUsersRow struct {
	Name   pgtype.Text `json:"name"`
	Coords interface{} `json:"coords"`
}

func (q *Queries) ListNearbyUsers(ctx context.Context, arg ListNearbyUsersParams) ([]ListNearbyUsersRow, error) {
	rows, err := q.db.Query(ctx, listNearbyUsers, arg.StMakepoint, arg.StMakepoint_2, arg.StDwithin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNearbyUsersRow
	for rows.Next() {
		var i ListNearbyUsersRow
		if err := rows.Scan(&i.Name, &i.Coords); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserLocation = `-- name: UpdateUserLocation :exec
UPDATE "User"
SET coords = ST_Point($1, $2, 4326)
WHERE email = $3
`

type UpdateUserLocationParams struct {
	StPoint   interface{} `json:"st_point"`
	StPoint_2 interface{} `json:"st_point_2"`
	Email     pgtype.Text `json:"email"`
}

func (q *Queries) UpdateUserLocation(ctx context.Context, arg UpdateUserLocationParams) error {
	_, err := q.db.Exec(ctx, updateUserLocation, arg.StPoint, arg.StPoint_2, arg.Email)
	return err
}
